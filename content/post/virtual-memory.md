---
title: "虚拟内存介绍"
author: Scott
tags:
  - 操作系统
categories:
  - 技术
date: 2020-07-03T17:29:01+08:00
draft: false
---

原文地址：https://github.com/angrave/SystemProgramming/wiki/Virtual-Memory,-Part-1:-Introduction-to-Virtual-Memory 

## 一、什么是虚拟内存？

在非常简单的嵌入式系统和早期的计算机中，进程直接访问内存，即 “地址1234” 对应于存储在物理内存的特定部分的特定字节。在现代系统中，情况已经不同了。相反，每个进程都是独立的; 并且在特定 CPU 指令或进程的数据片段的地址和物理内存(RAM)的实际字节之间存在一个转换进程。内存地址不再是“真实的” ; 进程在虚拟内存中运行。虚拟内存不仅保证了进程的安全(因为一个进程不能直接读取或修改另一个进程的内存) ，还允许系统有效地将内存分配（allocate）和再分配（re-allocate）给不同的进程。

### 什么是 MMU？

**内存管理单元（Memory Management Unit）是 CPU 的一部分，将虚拟内存地址转换为物理地址。** 如果当前没有从特定虚拟地址到物理地址的映射，或者当前 CPU 指令试图写到进程只有读访问权限的位置，MMU 也可能中断 CPU。

### 怎样将虚拟地址转换为物理地址？

假设你有一台32位的机器。指针可以容纳32位，也就是说它们可以存储2^32个不同的位置，也就是说它们可以存储4GB 的内存(我们将遵循一个地址可以存储一个字节的标准惯例)。

假设我们有一个大表，存储了常用的数据，对于每一个可能的地址(全部40亿个) ，我们将存储“真实的”即物理地址。每个物理地址将需要4个字节(容纳32位)。这个方案需要160亿字节来存储所有的条目。我们的查找方案将消耗我们的所有内存。因此，我们的查找表最好小于我们的内存，否则我们将没有空间留给我们的实际程序和操作系统数据。解决方案是将内存分块到称为“页（page）”和“帧（frame）”的小区域，并为每个页面使用一个查找表。

## 二、什么是页？

页（page）是一块虚拟内存。Linux 操作系统上的典型块大小为4KB (即`2^12`个地址) ，不过您可以找到较大块的案例。

因此，与其讨论单个字节，我们可以讨论 `4kb` 的块，每个块称为页。我们也可以给我们的页编号(“第0页”“第1页”等)。

### 示例：一台32位机器有多少个页(假设页面大小为4KB) ？

答: 2^32 / 2^12 = 2^20

>  备注：
>  - 2^10是1024，所以2^20比100万多一点。
>  - 对于一台64位机器，2^64 / 2^12 = 2^52，大约是10^15 页

### 什么是帧（frame）？

**帧（有时称为“页帧”）是一块物理内存或 RAM (Random Access Memory)**。这种存储器有时被称为“主存储器”。

### 什么是页表（page table）？

**页表（page table）是页与帧之间的映射。**例如，第1页可能映射到第45帧，第2页映射到第30帧。其他帧可能当前未使用，或分配给其他正在运行的进程，或由操作系统在内部使用。

一个简单的页表只是一个数组，`int frame = table[ page_num ];`

对于一个4KB 页面的32位机器，每个条目需要保存一个帧号——也就是20位，因为我们计算出有2 ^ 20帧。那就是每个条目2.5字节！在实践中，我们将每个条目四舍五入到4字节，并找到这些备用位的用途。每个条目需要4个字节 x 2 ^ 20个条目 = 4 MB 的物理内存来保存页表。

对于4KB 页面的64位机器，每个条目需要52位。让我们将每个条目的四舍五入数提高到64位(8字节)。对于2 ^ 52条目，那就是2 ^ 55个字节(大约40个千兆字节...)哎呀，我们的页表太大了。

在64位体系结构中，内存地址是稀疏的，所以我们需要一种机制来减少页表大小，因为大多数条目将永远不会被使用。

![这里是页表的一个可视化示例](https://blog-1252438081.cos.ap-shanghai.myqcloud.com/img/687474703a2f2f7777772e63732e6f64752e6564752f7e6373343731772f737072696e6731322f6c656374757265732f4d61696e4d656d6f72795f66696c65732f696d6167653032382e6a7067.jpeg)

### 什么是偏移量？

我们的页表将页映射到帧，但是每个页是一个连续地址块。我们如何计算在一个特定的帧中使用哪个特定的字节？解决方案是直接重用虚拟内存地址的最低位。例如，假设我们的进程正在读取以下地址-`VirtualAddress = 11110000111100001111000010101010`(二进制)

在页面大小为256字节的机器上，最小的8位(10101010)将用作偏移量。其余较高的位将是页码(111100001111000011110000)。

### 多级页表

对于64位体系结构，多级页面是解决页面表大小问题的一种方案。我们将研究最简单的实现——一个两级页表。每个表都是指向下一级表的指针列表，并非所有子表都需要存在。例如，32位体系结构的两级页表如下-所示：

```
VirtualAddress = 11110000111111110000000010101010 (binary)
                 |_Index1_||        ||          | 10 bit Directory index
                           |_Index2_||          | 10 bit Sub-table index
                                     |__________| 12 bit offset (passed directly to RAM)
```

在上述方案中，确定帧数需要两个内存读取: 最上面的10位用于页表目录。如果每个条目使用2个字节，那么我们只需要2KB 来存储整个目录。每个子表将指向物理帧(即存储20位所需的4个字节)。但是，对于只需要很少内存的进程，我们只需要为低内存地址(用于堆和程序代码)和高内存地址(用于堆栈)指定条目。每个子表有1024个条目 x 4个字节，即每个子表有4KB。

因此，我们的多级页表的总内存开销已经从4 MB (单级实现)减少到3帧内存(12KB) ！原因如下: 我们需要至少一个框架用于高级目录，两个框架只用于两个子表。一个子表用于低地址(程序代码、常量和可能的小堆) ，另一个子表用于环境和堆栈使用的高地址。实际上，真正的程序可能需要更多的子表条目，因为每个子表只能引用`1024 * 4KB = 4 MB` 的地址空间，但主要内容仍然有效——我们已经大大减少了执行页表查找所需的内存开销。

### 页表是否会使内存访问变慢? (什么是 TLB)

是的——非常明显！(但多亏了聪明的硬件，通常没有...)相比直接读写内存。对于单页表，我们的机器现在速度是原来的两倍！(需要两个内存访问)对于一个两级的页表，内存访问现在是原来的三倍慢。(需要三个内存访问)

为了克服这种开销，MMU 包括一个关联缓存，其中包含最近使用的虚拟页面到帧的查找。这个缓存被称为 TLB (“转译后备缓冲器”)。每当需要将虚拟地址转换为物理内存位置时，就会并行地查询 TLB。对于大多数程序的大多数内存访问，很有可能 TLB 已经缓存了结果。然而，如果一个程序没有良好的缓存一致性(例如从许多不同页面的随机内存位置读取) ，那么 TLB 就不会有结果缓存，现在 MMU 必须使用慢得多的页表来确定物理帧。

![如何拆分一个多层次的页表](https://blog-1252438081.cos.ap-shanghai.myqcloud.com/img/68747470733a2f2f75706c6f61642e77696b696d656469612e6f72672f77696b6970656469612f636f6d6d6f6e732f7468756d622f382f38652f5838365f506167696e675f344b2e7376672f34343070782d5838365f506167696e675f344b2e7376672e706e67.png)

## 三、高级帧和页保护

### 帧（frame）可以在进程之间共享吗? 

除了存储帧编号之外，**页表还可用于存储进程是否可以写入或只读取特定帧。然后可以在多个进程之间安全地共享只读帧。**例如，C语言库指令代码可以在动态将代码加载到进程内存的所有进程之间共享。每个进程只能读取该内存。这意味着如果您尝试写入内存中的只读页面，您将得到一个 `SEGFAULT`。这就是为什么有时内存访问 segfault，有时不访问 segfault，这完全取决于您的硬件是否允许访问。

此外，进程可以使用 `mmap` 系统调用与子进程共享页面。`mmap` 是一个有趣的调用，因为它不是将每个虚拟地址绑定到一个物理帧，而是将它绑定到其他东西。其他的东西可以是一个文件，一个 GPU 单元，或者任何你能想到的内存映射操作！写入内存地址可能会写入设备，或者写入操作系统可能会暂停，但这是一个非常强大的抽象，因为通常操作系统能够执行优化（多个进程内存映射同一个文件可以让内核创建一个映射）。



除了上面讨论的只读位和使用率统计信息之外，**页表通常还存了只读、修改和执行信息**。

### 什么是页错误（Page fault）？

页错误是指正在运行的程序试图访问其地址空间中未映射到物理内存的虚拟内存。在其他情况下也会出现页错误。

有三种类型的 Page fault：

**Minor：**如果页还没有映射，但它是一个有效的地址。这可能是 `sbrk (2)` 请求的内存，但尚未写入，这意味着操作系统可以在分配空间之前等待第一次写入。操作系统只是简单地创建页面，将其加载到内存中，然后继续运行。

**Major：**如果映射到的页不在内存中，而是在磁盘上。这样做的目的是将页面交换到内存中，并交换出另一个页面。如果这种情况发生得足够频繁，那你的程序肯定是在考验 MMU。

**Invalid：** 当你尝试写入不可写（non-writable ）内存地址或读取不可读（non-readable）内存地址时。MMU 会生成一个无效的错误，操作系统通常会生成一个 `SIGSEGV`，意味着分段冲突，这意味着你在可以写入的段之外编写了代码。

### 只读位（Read-only bit）

**只读位将页标记为只读。**尝试写入页面将导致页面错误。然后，页面错误将由内核处理。只读页面的两个例子包括在多个进程之间共享 c 运行时库(为了安全起见，您不会希望允许一个进程修改库) ; 以及复制-写入(Copy-On-Write) ，其中复制页面的成本可以延迟到第一次写入发生时。

### 页重写标志位（Dirty bit）

http://en.wikipedia.org/wiki/Page_table#Page_table_data

> 页重写标志位允许进行性能优化。磁盘上的页面被调入物理内存，然后读取，然后再调出，因为页面没有更改，所以不需要将其写回磁盘。但是，如果页面在分页后被写入，那么它的脏位将被设置，这表示页面必须被写回后备存储。这个策略要求后台存储在页面被分页到内存之后保留一个副本。当不使用脏位时，后台存储区只需要与任何时刻所有分页输出页面的瞬时总大小一样大。当使用脏位时，在物理内存和后备存储中始终存在一些页。

### 执行位（Execution bit）

**执行位标记页中的字节是否可以作为 CPU 指令执行。**通过禁用页，它可以防止恶意存储在进程内存中的代码（例如堆栈溢出）被轻易执行。(参考: http://en.wikipedia.org/wiki/nx_bit#hardware_background )

### 扩展阅读

在 x86平台上，越来越多的关于分页和页位的技术讨论出现在了[ http://wiki.osdev.org/paging ]上