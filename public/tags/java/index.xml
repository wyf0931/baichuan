<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Java on Mehameha</title>
    <link>/tags/Java/</link>
    <description>Recent content in Java on Mehameha</description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Thu, 02 Jan 2020 11:23:00 +0000</lastBuildDate>
    
	<atom:link href="/tags/Java/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Maven Deploy Plugin 使用方法</title>
      <link>/post/maven-deploy-plugin/</link>
      <pubDate>Thu, 02 Jan 2020 11:23:00 +0000</pubDate>
      
      <guid>/post/maven-deploy-plugin/</guid>
      <description>&lt;p&gt;本文介绍Maven 项目中如何通过 deploy plugin 配置来跳过某些不需要 deploy 的maven 模块。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Intellij IDEA 配置 Google Code Style</title>
      <link>/post/intellij-google-code-style-config/</link>
      <pubDate>Fri, 20 Dec 2019 12:56:52 +0800</pubDate>
      
      <guid>/post/intellij-google-code-style-config/</guid>
      <description>&lt;p&gt;本文介绍如何在 Intellij IDEA 中配置Google 开源的  Java Code Style。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Java 基础知识总结</title>
      <link>/post/java-basic-wiki/</link>
      <pubDate>Wed, 04 Sep 2019 15:41:00 +0000</pubDate>
      
      <guid>/post/java-basic-wiki/</guid>
      <description>一、线程 1、新建线程 继承 Thread 类，重写 run 方法； 实现 Runnable 接口； 实现 Callable 接口； 注意： 由于 Java 不能多继承，所以推荐使用接口方式创建线程。 2、线程状态与转化 Java 中的 RUNNABLE 状态对应操作系统中的 READY 、RUNNING ； Java 中的 synchronized 方法或块代码会触发 BLOCKED 状态； 使用 java.util.concurrent.locks 加锁，会触发 WAITING 、TIMED_WAITING 状态； 3、线</description>
    </item>
    
    <item>
      <title>怎样处理 InterruptedException</title>
      <link>/post/java-interrupted-exception/</link>
      <pubDate>Mon, 22 Jul 2019 21:45:00 +0000</pubDate>
      
      <guid>/post/java-interrupted-exception/</guid>
      <description>&lt;p&gt;您在编写一个测试程序，程序需要暂停一段时间，于是调用&lt;code&gt;Thread.sleep()&lt;/code&gt;。但是编译器或 IDE 报错说没有处理检查到的 &lt;code&gt;InterruptedException&lt;/code&gt;。&lt;code&gt;InterruptedException&lt;/code&gt; 是什么呢，为什么必须处理它？&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Groovy 与 Java 的区别</title>
      <link>/post/groovy-deffence-java/</link>
      <pubDate>Wed, 03 Jul 2019 15:13:00 +0000</pubDate>
      
      <guid>/post/groovy-deffence-java/</guid>
      <description>在 Groovy 语言设计之初，就遵从了 Least Surprise 原则，可以让 Java 程序员更快适应 Groovy。 我们列出了 Java 和 Groovy 之间的所有主要区别。 默认导入 Groovy 默认情况下导入以下包和类，可以不用显式的以 import 语句来导入它们： java.io.* java.lang.* java.math.BigDecimal java.math.BigInteger java.net.* java.util.* groovy.lang.* groovy.util.* 多方法（Multi-methods） 在 Groovy 中，将在运行时选择将调用的方法，称为运行时调度</description>
    </item>
    
    <item>
      <title>JDK 故障排除工具介绍</title>
      <link>/post/jdk-tools-trouble-shooting/</link>
      <pubDate>Wed, 03 Jul 2019 12:24:00 +0000</pubDate>
      
      <guid>/post/jdk-tools-trouble-shooting/</guid>
      <description>&lt;p&gt;下面的工具可以用来解决特定的故障排除任务。
本文中的工具目前还在试验阶段，不推荐使用，使用前请三思。在未来的 JDK 版本中可能会移除。有些工具目前无法在 Windows 平台上使用。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>J2SE HotSpot 虚拟机 GC 调优指南</title>
      <link>/post/J2SE-HotSpot-VM-GC-tuning/</link>
      <pubDate>Wed, 03 Jul 2019 10:44:00 +0000</pubDate>
      
      <guid>/post/J2SE-HotSpot-VM-GC-tuning/</guid>
      <description>JVM 为垃圾收集器、堆大小和运行时编译器提供了依赖于平台的默认选项。这些选项符合不同类型应用程序的需求，同时需要较少的命令行调整。此外，基于行为的调优动态调整堆的大小，以满足应用程序的指定行为。 本节介绍这些默认选项和基于行为的调优。 垃圾收集器、堆和运行时编译器默认选项 服务器级机器定义</description>
    </item>
    
    <item>
      <title>Ubuntu 安装 JDK 8 </title>
      <link>/post/ubuntu-install-jdk8/</link>
      <pubDate>Tue, 02 Jul 2019 16:17:00 +0000</pubDate>
      
      <guid>/post/ubuntu-install-jdk8/</guid>
      <description>&lt;p&gt;本文介绍如何在 Ubuntu 环境安装 Oracle JDK。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Java 整数类型与取值范围</title>
      <link>/post/java-integer/</link>
      <pubDate>Tue, 02 Jul 2019 16:03:00 +0000</pubDate>
      
      <guid>/post/java-integer/</guid>
      <description>&lt;!-- raw HTML omitted --&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;本文主要介绍JVM中整数类型以及各类型值的范围区间。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>JVM 运行时数据区介绍</title>
      <link>/post/jvm-runtime-data-areas/</link>
      <pubDate>Tue, 02 Jul 2019 14:47:00 +0000</pubDate>
      
      <guid>/post/jvm-runtime-data-areas/</guid>
      <description>&lt;p&gt;JVM 定义了在执行程序期间使用的各种运行时数据区（Run-Time Data Areas），其中一些数据区的生命周期与 JVM 进程相同，其他数据区是每个线程拥有一个，其生命周期与线程的生命周期相同。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Java 高级并发对象之 Lock 对象</title>
      <link>/post/java-concurrent-lock/</link>
      <pubDate>Mon, 01 Jul 2019 15:25:00 +0000</pubDate>
      
      <guid>/post/java-concurrent-lock/</guid>
      <description>本文主要介绍 Java 并发控制中常用的 Lock 对象。 同步代码依赖于一种简单的可重入锁。这种锁很容易使用，但有很多限制。 java.util.concurrent.locks 包支持更复杂的锁定方式。我们不会详细的研究这个包，而是将重点放在它最基本的接口Lock上。 锁对象非常像 synchronized 代码使用的隐式锁。与隐式锁一样，一次只有一个线程拥有一个 Lock 对象。Loc</description>
    </item>
    
    <item>
      <title>Java 常用技术总结</title>
      <link>/post/java-techs/</link>
      <pubDate>Sat, 29 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>/post/java-techs/</guid>
      <description>Java 构建线程：Runable、Callable 、Thread Java 并发安全：synchronized、Lock（ReentrantLock、ReadWriteLock） Java 关键词：volatile、synchronized Java 常用集合（ConcurrentHashMap、HashMap、H</description>
    </item>
    
    <item>
      <title>Java 线程生命周期</title>
      <link>/post/java-thread-lifecycle/</link>
      <pubDate>Sat, 29 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>/post/java-thread-lifecycle/</guid>
      <description>&lt;p&gt;Java 线程生命周期是什么呢？在不同阶段又有什么含义呢？&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>